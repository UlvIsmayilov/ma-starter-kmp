# Calling Swift Code from Kotlin (iosMain)

## Overview

To use Swift code in Kotlin/Native (iosMain), you need to create an **Objective-C bridging layer** because Kotlin/Native can only directly interop with Objective-C, not Swift.

## Method 1: Swift → Objective-C → Kotlin (Recommended)

### Step 1: Create Swift Code with @objc

```swift
// In your iOS app: SwiftHelpers.swift

import Foundation
import UIKit

// IMPORTANT: Use @objc and inherit from NSObject to expose to Kotlin
@objc public class SwiftLocationManager: NSObject {
    
    @objc public func getCurrentLocation() -> String {
        // Your Swift implementation
        return "37.7749, -122.4194"
    }
    
    @objc public func requestLocationPermission() {
        // Request permission
        print("Requesting location permission...")
    }
}

@objc public class SwiftCameraManager: NSObject {
    
    @objc public func openCamera(completion: @escaping (Bool) -> Void) {
        // Camera implementation
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
            completion(true)
        }
    }
    
    @objc public func capturePhoto() -> UIImage? {
        // Capture photo logic
        return nil
    }
}

@objc public class SwiftKeychainManager: NSObject {
    
    @objc public func saveToKeychain(key: String, value: String) -> Bool {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: key,
            kSecValueData as String: value.data(using: .utf8)!
        ]
        
        SecItemDelete(query as CFDictionary)
        let status = SecItemAdd(query as CFDictionary, nil)
        return status == errSecSuccess
    }
    
    @objc public func getFromKeychain(key: String) -> String? {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: key,
            kSecReturnData as String: true
        ]
        
        var result: AnyObject?
        let status = SecItemCopyMatching(query as CFDictionary, &result)
        
        if status == errSecSuccess, let data = result as? Data {
            return String(data: data, encoding: .utf8)
        }
        return nil
    }
}

// Example with protocol/delegate pattern
@objc public protocol SwiftDataDelegate {
    func onDataReceived(data: String)
    func onError(error: String)
}

@objc public class SwiftNetworkManager: NSObject {
    @objc public weak var delegate: SwiftDataDelegate?
    
    @objc public func fetchData(url: String) {
        // Network call
        DispatchQueue.global().asyncAfter(deadline: .now() + 2.0) {
            DispatchQueue.main.async {
                self.delegate?.onDataReceived(data: "Sample data from \(url)")
            }
        }
    }
}
```

### Step 2: Create Objective-C Bridging Header (if needed)

If you're in a pure iOS project, you might need a bridging header:

```objective-c
// SwiftBridge-Bridging-Header.h

// This file is automatically generated by Xcode when you add Swift to an Objc project
// Or create it manually in mixed projects
```

### Step 3: Use in Kotlin (iosMain)

```kotlin
// In iosMain: SwiftInterop.kt

import platform.Foundation.*
import platform.UIKit.*

// Swift classes exposed via @objc are available in Kotlin!
class LocationService {
    private val swiftManager = SwiftLocationManager()
    
    fun getLocation(): String {
        return swiftManager.getCurrentLocation()
    }
    
    fun requestPermission() {
        swiftManager.requestLocationPermission()
    }
}

class CameraService {
    private val swiftCamera = SwiftCameraManager()
    
    fun openCamera(onResult: (Boolean) -> Unit) {
        swiftCamera.openCameraWithCompletion { success ->
            onResult(success)
        }
    }
    
    fun capturePhoto() {
        val photo = swiftCamera.capturePhoto()
        println("Photo captured: $photo")
    }
}

class KeychainService {
    private val swiftKeychain = SwiftKeychainManager()
    
    fun saveSecure(key: String, value: String): Boolean {
        return swiftKeychain.saveToKeychainWithKey(key, value = value)
    }
    
    fun getSecure(key: String): String? {
        return swiftKeychain.getFromKeychainWithKey(key)
    }
}

// Using delegate pattern
class NetworkService {
    private val swiftNetwork = SwiftNetworkManager()
    
    fun fetchData(url: String, onData: (String) -> Unit, onError: (String) -> Unit) {
        // Implement the delegate
        swiftNetwork.delegate = object : NSObject(), SwiftDataDelegateProtocol {
            override fun onDataReceived(data: String) {
                onData(data)
            }
            
            override fun onError(error: String) {
                onError(error)
            }
        }
        
        swiftNetwork.fetchDataWithUrl(url)
    }
}
```

## Method 2: Use Objective-C Wrapper (For Complex Swift)

If Swift code can't be easily exposed with @objc, create an Objective-C wrapper:

### Step 1: Create Swift Code (Pure Swift)

```swift
// SwiftAdvancedFeatures.swift

import Foundation

// Pure Swift class (no @objc)
class SwiftAdvancedManager {
    func processData<T>(data: T) -> String where T: Codable {
        // Complex Swift features
        return "Processed"
    }
}
```

### Step 2: Create Objective-C Wrapper

```objective-c
// SwiftBridge.h

#import <Foundation/Foundation.h>

@interface SwiftBridge : NSObject

- (NSString *)processSimpleData:(NSString *)data;

@end
```

```objective-c
// SwiftBridge.m

#import "SwiftBridge.h"
#import "YourApp-Swift.h" // Auto-generated header

@implementation SwiftBridge

- (NSString *)processSimpleData:(NSString *)data {
    SwiftAdvancedManager *manager = [[SwiftAdvancedManager alloc] init];
    return [manager processDataWithData:data];
}

@end
```

### Step 3: Use in Kotlin

```kotlin
import platform.Foundation.*

class DataProcessor {
    private val bridge = SwiftBridge()
    
    fun process(data: String): String {
        return bridge.processSimpleData(data) ?: ""
    }
}
```

## Method 3: Shared Framework (For KMP Projects)

In a KMP project, your iOS app imports the shared framework:

### Project Structure:
```
iOS App (Swift/SwiftUI)
  ├── Uses → Shared Framework (Kotlin)
  └── Provides Swift helpers via interface injection

Shared Framework (Kotlin)
  ├── commonMain (Common code)
  ├── iosMain (iOS-specific Kotlin)
  └── Expects interfaces to be implemented by iOS app
```

### Implementation:

**In commonMain (Define interface):**
```kotlin
interface SwiftBiometricAuth {
    fun authenticate(completion: (Boolean, String?) -> Unit)
    fun canUseBiometrics(): Boolean
}
```

**In iosMain (Use in Kotlin):**
```kotlin
class AuthService(private val biometricAuth: SwiftBiometricAuth) {
    fun login(onSuccess: () -> Unit, onError: (String) -> Unit) {
        if (biometricAuth.canUseBiometrics()) {
            biometricAuth.authenticate { success, error ->
                if (success) {
                    onSuccess()
                } else {
                    onError(error ?: "Unknown error")
                }
            }
        }
    }
}
```

**In iOS App (Swift - Implement interface):**
```swift
import Shared
import LocalAuthentication

class BiometricAuthImplementation: SwiftBiometricAuth {
    func authenticate(completion: @escaping (Bool, String?) -> Void) {
        let context = LAContext()
        var error: NSError?
        
        if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {
            context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, 
                                 localizedReason: "Authenticate") { success, error in
                DispatchQueue.main.async {
                    completion(success, error?.localizedDescription)
                }
            }
        } else {
            completion(false, error?.localizedDescription)
        }
    }
    
    func canUseBiometrics() -> Bool {
        let context = LAContext()
        return context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: nil)
    }
}

// Usage in Swift
let authImpl = BiometricAuthImplementation()
let authService = AuthService(biometricAuth: authImpl)
```

## Important Rules for Swift → Kotlin Interop

### ✅ What Works:

1. **Classes marked with @objc**
2. **NSObject subclasses**
3. **Basic types**: String, Int, Bool, Double, Float
4. **Collections**: Array, Dictionary, Set
5. **Closures/Blocks**: Swift closures become Kotlin lambdas
6. **Protocols marked @objc**
7. **Enums marked @objc**

### ❌ What Doesn't Work:

1. **Pure Swift classes** (without @objc)
2. **Swift generics**
3. **Swift structs** (use class instead)
4. **Swift optionals** (use Objective-C optionals)
5. **Swift tuples**
6. **Complex Swift features** (Result type, async/await before iOS 13)

## Best Practices

1. **For Simple Swift Code**: Use `@objc` and `NSObject`
2. **For Complex Swift**: Create Objective-C wrapper
3. **For KMP Projects**: Use interface injection pattern
4. **Naming**: Swift methods get camelCase in Kotlin
5. **Memory**: Both use ARC, so memory is managed automatically
6. **Threading**: Dispatch to main thread when needed

## Complete Example

See the files:
- `SwiftInteropExamples.swift` - Swift code examples
- `SwiftToKotlinBridge.kt` - Kotlin usage examples

## Summary

| Approach | When to Use | Complexity |
|----------|-------------|------------|
| **@objc annotation** | Simple Swift classes, protocols | Low ⭐ |
| **Objective-C wrapper** | Complex Swift with generics, structs | Medium ⭐⭐ |
| **Interface injection** | KMP projects, clean architecture | Medium ⭐⭐ |
| **Framework boundary** | Large iOS apps using KMP module | Low ⭐ |
